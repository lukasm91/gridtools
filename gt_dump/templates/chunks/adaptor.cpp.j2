// vi:syntax=cpp

namespace gridtools {
    #define GT_DUMP_IDENTIFIER_{{ context.name }} {{ context.hash }}

    template <typename Grid, typename... BoundPlaceholders, typename... BoundDataStores>
    struct generated_computation<std::integral_constant<long int, GT_DUMP_IDENTIFIER_{{ context.name }}>,
        Grid,
        std::tuple<arg_storage_pair<BoundPlaceholders, BoundDataStores>...>> {

        using bound_arg_storage_pairs =
            std::tuple<arg_storage_pair<BoundPlaceholders, BoundDataStores>...>;

        using StaticPtrsType = 
            gt_gen_helpers::computation_ptrs<std::tuple<arg_storage_pair<BoundPlaceholders, BoundDataStores>...>>;

        template <uint_t ArgId,
            typename... T,
            enable_if_t<GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0,
            typename RetType = GT_META_CALL(gt_gen_helpers::get_bound_arg_result_type, (ArgId, bound_arg_storage_pairs))>
        RetType get_arg(T &&...) const {
            using Position = GT_META_CALL(gt_gen_helpers::get_bound_arg_position, (ArgId, bound_arg_storage_pairs));
            return std::get<Position::value>(ptrs_.ptrs_);
        }

        template <uint_t ArgId,
            typename... Args,
            typename... DataStores,
            enable_if_t<!GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0,
            typename ArgKeys = GT_META_CALL(meta::transform, (gt_gen_helpers::get_tag_of_plh_t, std::tuple<Args...>)),
            typename ArgPosition = GT_META_CALL(meta::st_position, (ArgKeys, std::integral_constant<uint_t, ArgId>))>
        auto get_arg(arg_storage_pair<Args, DataStores> const &... srcs) const GT_AUTO_RETURN(
            (gt_gen_helpers::get_ptr(std::get<ArgPosition::value>(std::make_tuple(srcs...)).m_value)));

        template <uint_t ArgId,
            typename Ptrs,
            typename... T,
            enable_if_t<GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0>
        auto get_stride(Ptrs &&ptrs, T &&...) const GT_AUTO_RETURN(ptrs.template get_stride<ArgId>());

        template <uint_t ArgId,
            typename Ptrs,
            typename... Args,
            typename... DataStores,
            enable_if_t<!GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0,
            typename ArgKeys = GT_META_CALL(meta::transform, (gt_gen_helpers::get_tag_of_plh_t, std::tuple<Args...>)),
            typename ArgPosition = GT_META_CALL(meta::st_position, (ArgKeys, std::integral_constant<uint_t, ArgId>))>
        auto get_stride(Ptrs &&, arg_storage_pair<Args, DataStores> const &... srcs) const GT_AUTO_RETURN(
            (gt_gen_helpers::extract_stride(std::get<ArgPosition::value>(std::make_tuple(srcs...)).m_value)));

        template <uint_t ArgId,
            typename Ptrs,
            typename... T,
            enable_if_t<GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0>
        auto get_dim(Ptrs &&ptrs, T &&...) const GT_AUTO_RETURN(ptrs.template get_dim<ArgId>());

        template <uint_t ArgId,
            typename Ptrs,
            typename... Args,
            typename... DataStores,
            enable_if_t<!GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0,
            typename ArgKeys = GT_META_CALL(meta::transform, (gt_gen_helpers::get_tag_of_plh_t, std::tuple<Args...>)),
            typename ArgPosition = GT_META_CALL(meta::st_position, (ArgKeys, std::integral_constant<uint_t, ArgId>))>
        auto get_dim(Ptrs &&, arg_storage_pair<Args, DataStores> const &... srcs) const GT_AUTO_RETURN(
            (gt_gen_helpers::extract_dim(std::get<ArgPosition::value>(std::make_tuple(srcs...)).m_value)));

      public:
        generated_computation(Grid const& grid, std::tuple<arg_storage_pair<BoundPlaceholders, BoundDataStores>...>&& storages)
            : computation_(grid), storage_pairs_(storages) {
            ptrs_.assign(std::move(storages));
        }

        template <typename... Args, typename... DataStores>
        void run(arg_storage_pair<Args, DataStores> const&... srcs) {
            tuple_util::for_each(gt_gen_helpers::make_view_f{}, std::make_tuple(srcs...));
            tuple_util::for_each(gt_gen_helpers::make_view_f{}, storage_pairs_);
            computation_.run(
                {%- set comma = joiner(", ") -%}
                {%- for kind_id, kind_info in context.kinds|dictsort %}
                  {{ comma() }} get_stride<{{ kind_info.args|first }}>(ptrs_, srcs...)
                  {{ comma() }} get_dim<{{ kind_info.args|first }}>(ptrs_, srcs...)
                {%- endfor %}
                {%- for arg_id, arg_info in context.args|dictsort() %}
                  {{- comma() }} get_arg<{{ arg_id }}>(srcs...)
                {%- endfor %});
            tuple_util::for_each(gt_gen_helpers::sync_f{}, std::make_tuple(srcs...));
            tuple_util::for_each(gt_gen_helpers::sync_f{}, storage_pairs_);
        }
        void reset_meter() {}
        std::string print_meter() const { return ""; }

      private:
        gen_{{ context.name }}_{{ context.hash }}::generated_computation<Grid> computation_;
        StaticPtrsType ptrs_;
        bound_arg_storage_pairs storage_pairs_; // this would not belong in here, but that's an ugly interface which is fine...
    };
}
