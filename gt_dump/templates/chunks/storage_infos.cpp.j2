{#- TODO: We allow too much here: Temporaries only make sense for ij and ijk,
  but there is quite some code for other cases
#}
{%- for arg_id, arg_info in context.temporaries.items() %}
  {%- if not arg_info.local %}
    class kind_tmp_{{ arg_id }}_info {
      public:
        {%- set comma = joiner() %}
        kind_tmp_{{ arg_id }}_info({%- if not arg_info|masked(0) %}{{ comma() }}int stride_i_block {% endif -%}
                                     {%- if not arg_info|masked(1) %}{{ comma() }}int stride_j_block {% endif -%}
                                     {{ comma() }} int total_size)
            {%- set comma = joiner_first(sep=", ", first=': ') %}
            {%- if not arg_info|masked(0) %}{{ comma() }}stride_i_block_(stride_i_block) {%- endif -%}
            {%- if not arg_info|masked(1) %}{{ comma() }}stride_j_block_(stride_j_block) {%- endif -%}
            {{ comma() }}total_size_(total_size) {}

        kind_tmp_{{ arg_id }}_info() = default;

        GT_FUNCTION int get_offset(int i, int j, int k) const noexcept {
            return i * stride_0_ + j * stride_1_ + k * stride_2_;
        }
        GT_FUNCTION int get_block_offset(int i_block, int j_block) const noexcept {
            return stride_i_block_ * i_block + stride_j_block_ * j_block;
        }
        GT_FUNCTION int get_total_size() const noexcept { return total_size_; }

      private:
        static constexpr int stride_0_ = {{ 1 if not arg_info|masked(0) else 0 }}; // i_stride
        {%- if arg_info|masked(1) %}
          static constexpr int stride_1_ = 0; // j_stride
        {%- elif arg_info|masked(0) %}
          static constexpr int stride_1_ = 1; // j_stride
        {%- else %}
          static constexpr int stride_1_ =  helpers::get_blocked_i_padded_length<computation_info::max_arg_extent>::value; // j_stride
        {%- endif %}
        {%- if arg_info|masked(2) %}
          static constexpr int stride_2_ = 0; // k_stride
        {%- elif arg_info|masked(1) and arg_info|masked(0) %}
          static constexpr int stride_2_ = 1; // k_stride
        {%- elif arg_info|masked(1) %}
          static constexpr int stride_2_ =  helpers::get_blocked_i_padded_length<computation_info::max_arg_extent>::value; // k_stride
        {%- elif arg_info|masked(0) %}
          static constexpr int stride_2_ =  helpers::get_blocked_j_padded_length<computation_info::max_arg_extent>::value; // k_stride
        {%- else %}
          static constexpr int stride_2_ =  stride_1_ * helpers::get_blocked_j_padded_length<computation_info::max_arg_extent>::value; // k_stride
        {%- endif %}

        {%- if arg_info|masked(0) %}
          static constexpr int stride_i_block_ = 0;
        {%- else %}
          int stride_i_block_;
        {%- endif -%}

        {%- if arg_info|masked(1) %}
          static constexpr int stride_j_block_ = 0;
        {%- else %}
          int stride_j_block_;
        {%- endif %}

        int total_size_;
    };
  {%- endif %}
{% endfor %}

{%- for kind_id, kind_info in context.kinds.items() %}
  class kind_{{ kind_id }}_info {
    public:
      kind_{{- kind_id }}_info(const gt::array<int, {{ kind_info|kind_dimension }}>& strides,
                               const gt::array<int, {{ kind_info|kind_dimension }}>& dims) noexcept
          {%- set comma = joiner_first(sep=", ", first=': ') %}
          {%- set info_ns = namespace() %}
          {%- set info_ns.index = 0 %}
          {%- for i in range(kind_info.layout|length) %}
            {%- if not kind_info|masked(i) and not kind_info|unitstride(i) %}
              {{- comma() }}stride_{{ i }}_(strides[{{ info_ns.index }}])
            {% endif %}
            {%- set info_ns.index = info_ns.index + 1 if not kind_info|masked(i) else info_ns.index %}
          {%- endfor -%}
      {
          {%- set info_ns = namespace() %}
          {%- set info_ns.index = 0 %}
          {%- for i in range(kind_info.layout|length) %}
            {%- if kind_info|unitstride(i) %}
              assert(stride_{{ i }}_ == strides[{{ info_ns.index }}]);
            {%- endif %}
            {%- set info_ns.index = info_ns.index + 1 if not kind_info|masked(i) else info_ns.index %}
          {%- endfor %}

          total_size_ = 0;
          for (int i = 0; i < {{ kind_info|kind_dimension }}; ++i)
              total_size_ = std::max(total_size_, dims[i] * strides[i]);
      }
      kind_{{ kind_id }}_info() = default;

      GT_FUNCTION int get_offset(int i, int j, int k
          {%- for i in range(kind_info.layout|length - 3) %}
              , int n{{ i }} = 0
          {%- endfor %}) const noexcept {
        return i * stride_0_ + j * stride_1_ + k * stride_2_
          {%- for i in range(kind_info.layout|length - 3) %}
              + stride_{{ i + 3 }}_ * n{{ i }}
          {%- endfor %};
      }
      GT_FUNCTION int get_block_offset(int i_block, int j_block) const noexcept {
          return get_offset(helpers::block_i_size * i_block, helpers::block_j_size * j_block, 0);
      }
      GT_FUNCTION int get_total_size() const noexcept { return total_size_; }

    private:
      {%- for i in range(kind_info.layout|length) %}
        {%- if kind_info|unitstride(i) %}
          static constexpr int stride_{{ i }}_ = 1;
        {%- elif kind_info|masked(i) %}
          static constexpr int stride_{{ i }}_ = 0;
        {%- else %}
          int stride_{{ i }}_;
        {%- endif %}
      {%- endfor %}
      int total_size_;
  };
{% endfor %}
