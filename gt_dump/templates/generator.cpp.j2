// vi:syntax=cpp
// this code was generated

{% include 'chunks/includes.cpp.j2' %}
namespace gen_{{ context.name }}_{{ context.hash }} {
    {% filter indent(width=4) %}
    {%- include 'chunks/extent.cpp.j2' %}
    {%- include 'chunks/computation_info.cpp.j2' %}
    {%- include 'chunks/block_helpers.cpp.j2' %}
    {%- include 'chunks/storage_infos.cpp.j2' %}
    {%- include 'chunks/arg_map.cpp.j2' %}
    {%- include 'chunks/mss_ptrs.cpp.j2' %}
    {%- include 'chunks/eval.cpp.j2' %}
    {%- include 'chunks/launch_kernel.cpp.j2' %}
    {%- include 'chunks/run_multistage.cpp.j2' %}
    {%- include 'chunks/computation.cpp.j2' %}
    {%- endfilter %}

    template <typename LayoutMap>
    GT_META_DEFINE_ALIAS(si_array_t, gridtools::meta::id, (gridtools::array<int, LayoutMap::unmasked_length>));

    template <typename DataStore>
    auto get_ptr(DataStore const &data_store) GT_AUTO_RETURN((gridtools::advanced::get_raw_pointer_of(
        gridtools::make_target_view<gridtools::access_mode::read_only>(data_store))));

    template <typename T>
    struct AsIntegralConstants;
    template <template <int...> typename M, int... Is>
    struct AsIntegralConstants<M<Is...>> {
        using type = std::tuple<std::integral_constant<int, Is>...>;
    };

    template <typename LayoutMap,
        typename RetType = si_array_t<LayoutMap>>
    RetType extract_unmasked(gridtools::array<gridtools::uint_t, LayoutMap::masked_length> const& masked) {
        RetType ret;
        for (int read_pos = 0, write_pos = 0; read_pos < LayoutMap::masked_length; ++read_pos)
            if (LayoutMap::at(read_pos) != -1)
                ret[write_pos++] = masked[read_pos];

        return ret;
    }
    template <typename DataStore,
        typename LayoutMap = typename DataStore::storage_info_t::layout_t>
    auto extract_stride(DataStore const& data_store) GT_AUTO_RETURN(
        extract_unmasked<LayoutMap>(data_store.info().strides()));

    template <typename DataStore,
        typename LayoutMap = typename DataStore::storage_info_t::layout_t>
    auto extract_dim(DataStore const& data_store) GT_AUTO_RETURN(
        extract_unmasked<LayoutMap>(data_store.info().total_lengths()));

    template <typename StorageInfo>
    GT_META_DEFINE_ALIAS(extract_layout_map, gridtools::meta::id, typename StorageInfo::layout_t);

    template <typename BoundData>
    struct computation_ptrs ;
    template <typename... BoundPlaceholders, typename... BoundDataStores>
    struct computation_ptrs<std::tuple<gridtools::arg_storage_pair<BoundPlaceholders, BoundDataStores>...>> {
        using ptrs = std::tuple<typename BoundPlaceholders::data_store_t::data_t *...>;
        using storage_infos = GT_META_CALL(
            gridtools::meta::dedup, std::tuple<typename BoundPlaceholders::data_store_t::storage_info_t...>);
        using layout_maps = GT_META_CALL(gridtools::meta::transform, (extract_layout_map, storage_infos));
        using si_arrays = GT_META_CALL(gridtools::meta::transform, (si_array_t, layout_maps));

        using bound_arg_keys = GT_META_CALL(
            gridtools::meta::transform, (gridtools::gt_gen_helpers::get_tag_of_plh_t, std::tuple<BoundPlaceholders...>));

        ptrs ptrs_;
        si_arrays strides_;
        si_arrays dims_;

        struct assign_arg_f {
            ptrs& ptrs_;

            template <typename Placeholder,
                typename Datastore,
                typename PtrPosition = typename GT_META_CALL(gridtools::meta::st_position, (std::tuple<BoundPlaceholders...>, Placeholder))::type>
            void operator()(gridtools::arg_storage_pair<Placeholder, Datastore>&& arg) const {
                // normal accessor
                std::get<PtrPosition::value>(ptrs_) = get_ptr(arg.m_value);
            }
        };
        struct assign_si_f {
            si_arrays& strides_;
            si_arrays& dims_;

            template <typename Placeholder,
                typename Datastore,
                typename StorageInfo = typename Placeholder::data_store_t::storage_info_t,
                typename StrideArray = GT_META_CALL(si_array_t, typename StorageInfo::layout_t),
                typename SIPosition = typename GT_META_CALL(gridtools::meta::st_position, (storage_infos, StorageInfo))::type>
            void operator()(gridtools::arg_storage_pair<Placeholder, Datastore>&& arg) const {
                // normal accessor
                std::get<SIPosition::value>(strides_) = extract_stride(arg.m_value);
                std::get<SIPosition::value>(dims_) = extract_dim(arg.m_value);
            }
        };

        void assign(std::tuple<gridtools::arg_storage_pair<BoundPlaceholders, BoundDataStores>...>&& args) {
            auto assign_args = gridtools::tuple_util::for_each(assign_arg_f{ptrs_});
            assign_args(std::move(args));

            auto assign_si = gridtools::tuple_util::for_each(assign_si_f{strides_, dims_});
            assign_si(std::move(args));
        }

        template <gridtools::uint_t ArgId,
            typename ArgPosition = GT_META_CALL(gridtools::meta::st_position, (bound_arg_keys, std::integral_constant<gridtools::uint_t, ArgId>)),
            typename Placeholder = GT_META_CALL(gridtools::meta::at, (std::tuple<BoundPlaceholders...>, ArgPosition)),
            typename StorageInfo = typename Placeholder::data_store_t::storage_info_t>
        struct si_position {
            using type = GT_META_CALL(gridtools::meta::st_position, (storage_infos, StorageInfo));
        };
        template <gridtools::uint_t ArgId>
        using si_position_t = typename si_position<ArgId>::type;

        template <gridtools::uint_t ArgId>
        using si_array = GT_META_CALL(gridtools::meta::at, (si_arrays, si_position_t<ArgId>));

        template <gridtools::uint_t ArgId>
        si_array<ArgId> get_stride() const {
            return std::get<si_position_t<ArgId>::value>(strides_);
        }

        template <gridtools::uint_t ArgId>
        si_array<ArgId> get_dim() const {
            return std::get<si_position_t<ArgId>::value>(dims_);
        }
    };

} // namespace gen_{{ context.name }}_{{ context.hash }}

namespace gridtools {
    #define GT_DUMP_IDENTIFIER_{{ context.name }} {{ context.hash }}

    template <typename Grid, typename... BoundPlaceholders, typename... BoundDataStores>
    struct generated_computation<std::integral_constant<long int, GT_DUMP_IDENTIFIER_{{ context.name }}>,
        Grid,
        std::tuple<arg_storage_pair<BoundPlaceholders, BoundDataStores>...>> {

        using bound_arg_storage_pairs =
            std::tuple<arg_storage_pair<BoundPlaceholders, BoundDataStores>...>;

        using StaticPtrsType = 
            gen_{{ context.name }}_{{ context.hash }}::computation_ptrs<std::tuple<arg_storage_pair<BoundPlaceholders, BoundDataStores>...>>;

        template <uint_t ArgId,
            typename... T,
            enable_if_t<GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0,
            typename RetType = GT_META_CALL(gt_gen_helpers::get_bound_arg_result_type, (ArgId, bound_arg_storage_pairs))>
        RetType get_arg(T &&...) const {
            using Position = GT_META_CALL(gt_gen_helpers::get_bound_arg_position, (ArgId, bound_arg_storage_pairs));
            return std::get<Position::value>(ptrs_.ptrs_);
        }

        template <uint_t ArgId,
            typename... Args,
            typename... DataStores,
            enable_if_t<!GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0,
            typename ArgKeys = GT_META_CALL(meta::transform, (gt_gen_helpers::get_tag_of_plh_t, std::tuple<Args...>)),
            typename ArgPosition = GT_META_CALL(meta::st_position, (ArgKeys, std::integral_constant<uint_t, ArgId>))>
        auto get_arg(arg_storage_pair<Args, DataStores> const &... srcs) const GT_AUTO_RETURN(
            (gen_{{ context.name }}_{{ context.hash }}::get_ptr(std::get<ArgPosition::value>(std::make_tuple(srcs...)).m_value)));

        template <uint_t ArgId,
            typename Ptrs,
            typename... T,
            enable_if_t<GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0>
        auto get_stride(Ptrs &&ptrs, T &&...) const GT_AUTO_RETURN(ptrs.template get_stride<ArgId>());

        template <uint_t ArgId,
            typename Ptrs,
            typename... Args,
            typename... DataStores,
            enable_if_t<!GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0,
            typename ArgKeys = GT_META_CALL(meta::transform, (gt_gen_helpers::get_tag_of_plh_t, std::tuple<Args...>)),
            typename ArgPosition = GT_META_CALL(meta::st_position, (ArgKeys, std::integral_constant<uint_t, ArgId>))>
        auto get_stride(Ptrs &&, arg_storage_pair<Args, DataStores> const &... srcs) const GT_AUTO_RETURN(
            (gen_{{ context.name }}_{{ context.hash }}::extract_stride(std::get<ArgPosition::value>(std::make_tuple(srcs...)).m_value)));

        template <uint_t ArgId,
            typename Ptrs,
            typename... T,
            enable_if_t<GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0>
        auto get_dim(Ptrs &&ptrs, T &&...) const GT_AUTO_RETURN(ptrs.template get_dim<ArgId>());

        template <uint_t ArgId,
            typename Ptrs,
            typename... Args,
            typename... DataStores,
            enable_if_t<!GT_META_CALL(gt_gen_helpers::is_static_bound_arg, (ArgId, bound_arg_storage_pairs))::value, int> = 0,
            typename ArgKeys = GT_META_CALL(meta::transform, (gt_gen_helpers::get_tag_of_plh_t, std::tuple<Args...>)),
            typename ArgPosition = GT_META_CALL(meta::st_position, (ArgKeys, std::integral_constant<uint_t, ArgId>))>
        auto get_dim(Ptrs &&, arg_storage_pair<Args, DataStores> const &... srcs) const GT_AUTO_RETURN(
            (gen_{{ context.name }}_{{ context.hash }}::extract_dim(std::get<ArgPosition::value>(std::make_tuple(srcs...)).m_value)));

      public:
        generated_computation(Grid const& grid, std::tuple<arg_storage_pair<BoundPlaceholders, BoundDataStores>...>&& storages)
            : computation_(grid), storage_pairs_(storages) {
            ptrs_.assign(std::move(storages));
        }

        template <typename... Args, typename... DataStores>
        void run(arg_storage_pair<Args, DataStores> const&... srcs) {
            tuple_util::for_each(gt_gen_helpers::make_view_f{}, std::make_tuple(srcs...));
            tuple_util::for_each(gt_gen_helpers::make_view_f{}, storage_pairs_);
            computation_.run(
                {%- set comma = joiner(", ") -%}
                {%- for kind_id, kind_info in context.kinds|dictsort %}
                  {{ comma() }} get_stride<{{ kind_info.args|first }}>(ptrs_, srcs...)
                  {{ comma() }} get_dim<{{ kind_info.args|first }}>(ptrs_, srcs...)
                {%- endfor %}
                {%- for arg_id, arg_info in context.args|dictsort() %}
                  {{- comma() }} get_arg<{{ arg_id }}>(srcs...)
                {%- endfor %});
            tuple_util::for_each(gt_gen_helpers::sync_f{}, std::make_tuple(srcs...));
            tuple_util::for_each(gt_gen_helpers::sync_f{}, storage_pairs_);
        }
        void reset_meter() {}
        std::string print_meter() const { return ""; }

      private:
        gen_{{ context.name }}_{{ context.hash }}::generated_computation<Grid> computation_;
        StaticPtrsType ptrs_;
        bound_arg_storage_pairs storage_pairs_; // this would not belong in here, but that's an ugly interface which is fine...
    };
}
